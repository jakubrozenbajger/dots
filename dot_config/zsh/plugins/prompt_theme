# vim:ft=zsh ts=2 sw=2 sts=2

setopt prompt_subst

# prompt settings
_prompt_start=$(${SALT_BOLD_PROMPT:-false} && echo "%S %s" || echo "")
_show_date=${SALT_SHOW_DATE:-false}
_show_time=${SALT_SHOW_TIME:-true}
_show_vi=${SALT_SHOW_VI:-true}
_show_venv=${SALT_SHOW_VENV:-true}
_show_git=${SALT_SHOW_GIT:-true}
_show_user=${SALT_SHOW_USER:-true}

#disable default venv prompt
"$_show_venv" && export VIRTUAL_ENV_DISABLE_PROMPT=true

VICMD_INDICATOR="NORMAL"
VIINS_INDICATOR="INSERT"
#VICMD_INDICATOR="N"
#VIINS_INDICATOR="I"
prompt_vi_mode() {
  "$_show_vi" || return;
  local mode
  is_normal() {
    test -n "${${KEYMAP/vicmd/$VICMD_INDICATOR}/(main|viins)/}"  # param expans
  }
  if is_normal; then
    print -n "%S $VICMD_INDICATOR %s"
  else
    print -n " $VIINS_INDICATOR "
  fi
}

prompt_context() {
  local ctx
  if [ -n "$SSH_CLIENT" ]; then
    ctx="%{%F{magenta}%} %n@%m %{%f%}"
  else
    $_show_user && ctx=" %n "
  fi
  # if root red{user@host} else on remote magenta{user@host}, on local - {user}
  print -n "%(!.%{%F{white}%K{red}%} %n@%m %{%k%}%{%f%}.${ctx:-})"
}

prompt_virtualenv() {
  "$_show_venv" || return;
  local virtualenv_path="$VIRTUAL_ENV"
  if [[ -n $virtualenv_path ]]; then
    print -n "%{%F{blue}%}  $(basename "$virtualenv_path") %{%f%}"
  fi
}

PLUSMINUS="\u00b1"
ICOBRANCH="\uf126"
ICODETACHED="➦"
#ICOREMOTETRACK="☊"
ICOREMOTE="\uf0c1"
#ICOTAG="\uf02b"
#ICOTAG="\uf024"
ICOTAG="\u2691"
ICOSTASH="\u2699"
ICOWORKTREE="*"
ICOUNTRACK="?"
prompt_git() {
  "$_show_git" || return;
  # if not inside git repo do nothing
  [ "$(git rev-parse --is-inside-work-tree 2>/dev/null)" != "true" ] && return;

  local git_dir
  local modified untracked added deleted
  local commits_ahead commits_behind to_push to_pull

  git_dir=$(git rev-parse --git-dir 2>/dev/null)
  gst_porcelain=$(git status --porcelain=v2 --branch --ignore-submodules="${GIT_STATUS_IGNORE_SUBMODULES:-dirty}" 2> /dev/null)
  g_changes=$(\grep -v "^# " <<< "${gst_porcelain}")

  #REF
  read -r oid head upstream ab <<< "$(echo "$gst_porcelain" | grep "^# branch." | cut -d' ' -f3- | xargs)"
  if [ "$head" = "(detached)" ]; then
    ref_txt="$ICODETACHED ${oid:0:7} ";
  else
    ref_txt="$ICOBRANCH $head ";
  fi

  #UPSTREAM
  upstream_txt=""
  if [ -n "$upstream" ]; then
    upstream_txt="$upstream"
    [ "${upstream##*/}" = "$head" ] && upstream_txt="${upstream%%/*}"
    upstream_txt="$ICOREMOTE $upstream_txt "

    commits_ahead=0; _tmp_commits_ahead="${ab%% *}"; commits_ahead="${_tmp_commits_ahead##+}"
    commits_behind="${ab##* -}"
  fi

#  if [[ -n "$g_changes" ]]; then
#    g_base_color='yellow'
#  else
#    g_base_color='green'
#  fi

  # green - clean, yellow - all staged, red - unstaged changes or untracked files
  local g_base_color; g_base_color="green"
  local c_staged;       c_staged=$(grep -c "^[12]\ [^.]." <<< "${g_changes}");
  local c_worktree;   c_worktree=$(grep -c "^[12]\ .[^.]" <<< "${g_changes}");
  local c_untracked; c_untracked=$(grep -c "^?\ " <<< "${g_changes}");
  local c_unmerged;   c_unmerged=$(grep -c "^u\ " <<< "${g_changes}");
  stat_txt=""
  if [ "$c_staged" -gt 0 ];     then stat_txt="$stat_txt [$c_staged]";              g_base_color='yellow';  fi
  if [ "$c_worktree" -gt 0 ];   then stat_txt="$stat_txt $c_worktree$ICOWORKTREE";  g_base_color='red';     fi
  if [ "$c_untracked" -gt 0 ];  then stat_txt="$stat_txt $c_untracked$ICOUNTRACK";  g_base_color='red';     fi
  if [ "$c_unmerged" -gt 0 ];   then stat_txt="$stat_txt >$c_unmerged<";                                    fi
  [ -n "$stat_txt" ] && stat_txt=" |$stat_txt"

#  local git_status; git_status=$(git status --porcelain 2> /dev/null)
#
#  local number_of_untracked_files; number_of_untracked_files=$(\grep -c "^??" <<< "${git_status}")
#  # if [[ $number_of_untracked_files -gt 0 ]]; then untracked=" $number_of_untracked_files◆"; fi
#  if [[ $number_of_untracked_files -gt 0 ]]; then untracked=" $number_of_untracked_files☀"; fi
#
#  local number_added; number_added=$(\grep -c "^A" <<< "${git_status}")
#  if [[ $number_added -gt 0 ]]; then added=" $number_added✚"; fi
#
#  local number_modified; number_modified=$(\grep -c "^.M" <<< "${git_status}")
#  if [[ $number_modified -gt 0 ]]; then
#    modified=" $number_modified●"
#    g_base_color='red'
#  fi
#
#  local number_added_modified; number_added_modified=$(\grep -c "^M" <<< "${git_status}")
#  local number_added_renamed; number_added_renamed=$(\grep -c "^R" <<< "${git_status}")
#  if [[ $number_modified -gt 0 && $number_added_modified -gt 0 ]]; then
#    modified="$modified$((number_added_modified+number_added_renamed))$PLUSMINUS"
#  elif [[ $number_added_modified -gt 0 ]]; then
#    modified=" ●$((number_added_modified+number_added_renamed))$PLUSMINUS"
#  fi
#
#  local number_deleted; number_deleted=$(\grep -c "^.D" <<< "${git_status}")
#  if [[ $number_deleted -gt 0 ]]; then
#    deleted=" $number_deleted‒"
#    g_base_color='red'
#  fi
#
#  local number_added_deleted; number_added_deleted=$(\grep -c "^D" <<< "${git_status}")
#  if [[ $number_deleted -gt 0 && $number_added_deleted -gt 0 ]]; then
#    deleted="$deleted$number_added_deleted$PLUSMINUS"
#  elif [[ $number_added_deleted -gt 0 ]]; then
#    deleted=" ‒$number_added_deleted$PLUSMINUS"
#  fi

  # TODO: use `git tag --points-at=HEAD` ?
  tag_txt=""
  tag_at_current_commit=$(git describe --exact-match --tags "$oid" 2> /dev/null)
  if [ -n "$tag_at_current_commit" ]; then
    tag_txt="$ICOTAG $tag_at_current_commit ";
  fi

  stash_txt=""
  number_of_stashes="$(wc -l "$git_dir/logs/refs/stash" 2> /dev/null)" #probably faster
  number_of_stashes="${number_of_stashes%% *}"
  #number_of_stashes="$(git stash list 2> /dev/null | wc -l)"
  if [ "$number_of_stashes" -gt 0 ]; then
    stash_txt="$ICOSTASH ${number_of_stashes}"
  fi

  # FIXME: move to proper position
  [ "$commits_ahead" -gt 0 ]  && to_push="%f%F{cyan}↑$commits_ahead%f%F{$g_base_color} "
  [ "$commits_behind" -gt 0 ] && to_pull="%f%F{red}↓$commits_behind%f%F{$g_base_color} "

  mode="" # multiple motes are possible (you can rebase while bisecting)
  [ -e "${git_dir}/BISECT_LOG" ] && mode="$mode<B> ";
  [ -e "${git_dir}/MERGE_HEAD" ] && mode="$mode>M< ";
  [[ -e "${git_dir}/rebase" || -e "${git_dir}/rebase-apply" || -e "${git_dir}/rebase-merge" || -e "${git_dir}/../.dotest" ]] && mode="$mode>R> ";

  # TODO: handle spaces after segments here
  g_prompt_txt="${upstream_txt}${to_push}${to_pull}${ref_txt}${mode}${tag_txt}${stash_txt}${stat_txt}$untracked$modified$deleted$added"
  print -n "%F{$g_base_color} $g_prompt_txt %f"
}

prompt_dir() {
  print -n " %~ "
}

prompt_date() {
  "$_show_date" || return;
  print -n " %D{%Y-%m-%d} "
}

prompt_time() {
  "$_show_time" || return;
  print -n " %D{%H:%M} "
}

SYMBOL_ERR="\u2718"
SYMBOL_JOB="\u2699"
prompt_status() {
  err_prompt="%0(?..%{%F{red}%} $SYMBOL_ERR %? %f)"
  jobs_prompt="%1(j.%{%F{cyan}%} $SYMBOL_JOB %j %f.)"
  print -n "$err_prompt$jobs_prompt"
}

SYMBOL_CMD=" $ "
SYMBOL_CMD_SU="%{%F{red}%} # %{%f%}"
prompt_cmd() {
  print -n "%(!.$SYMBOL_CMD_SU.$SYMBOL_CMD)"
}

## Main prompt
build_prompt() {
  print -n "\n$_prompt_start"
  prompt_status
  prompt_context
  prompt_dir
  prompt_virtualenv
  prompt_git
  print -n "\n$_prompt_start"
  prompt_cmd
}

build_rprompt() {
  prompt_vi_mode
  prompt_date
  prompt_time
}

# shellcheck disable=SC2016,SC2034
PROMPT='%B$(build_prompt)%b'
# shellcheck disable=SC2016,SC2034
RPROMPT='%B$(build_rprompt)%b'
